---
title: "Disaggregate Curves"
author: "Caliper Corporation"
date: "February 9, 2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(dplyr.summarise.inform = FALSE)
options(scipen = 999)

library(tidyverse)
library(plotly)
library(knitr)
library(kableExtra)
source("R/load_census_data.R")
source("R/calc_shares.R")
```

```{r load census data, include=FALSE}
shapes <- load_census_data()

acs_bg <- shapes$acs_bg
acs_tract <- shapes$acs_tract
dec_bg <- shapes$dec_bg

taz <- sf::read_sf("data/input/tazs/tazs 2020-12-08.shp") %>%
  st_transform(crs = st_crs('+proj=longlat +datum=WGS84'))
taz <- st_transform(taz, st_crs(acs_bg)) %>% st_make_valid()
```

# Stratification curves

The first step in synthesizing the population of residents in the TRMG2 is to 
develop univariate or one-dimensional marginal distributions describing the 
population in each zone based on the limited demographic variables forecast 
for each zone, typically averages. In other words, the model starts by 
determining the number of single person, two person, three person, etc., 
households in each zone based on the average household size in the zone. 

Rather than use stratification curves to convert simple zonal input variables
such as average household size into a distribution of households by size, 
some travel model population synthesizers require the user to supply the 
number of households by size. However, this puts a considerable burden on 
data development for future year scenarios which is difficult for agencies 
lacking staff dedicated to demographic forecasting. 

Therefore, to keep the data development burden as light as possible, Caliper has
retained the approach of using stratification curves in the TRMG2, although the
specific implementation has changed. These curves simply encode information on
the extent to which, for example, a zone with 3.5 persons-per-household on
average will have a high percentage of 3- and 4-person households and a zone
with an average of 1.5 persons-per- household will have more 1- and 2-person
households.

In the Triangle, the marginal distribution curves estimated are:

  * Size (1-4+)
  * Income
    * Low: \$0 - \$34,999
    * Medium-Low: \$35,000 - \$74,999
    * Medium-High: \$75,000 - \$149,999
    * High: \$150,000 and above
  * Workers (0-3+)
  
These curves are estimated from Census data, and the data is taken from
different data products and geographies depending on availability. For example,
the data needed to estimate the worker curve is only available from the American
Community Survey (ACS) product known as the Census Transportation Planning
Package (CTPP). Vehicle and income information is available from the ACS 5-year
file directly, and size information is available from multiple products.

```{r, include=FALSE}
# Read in worker data from CTPP table A112109 at the TAZ level.
# It isn't available from the ACS at anything below tract, which is too coarse.
ctpp_tbl <- read_csv(
  "data/input/census_data/2012_2016_ctpp_workers.csv", skip = 2
) %>%
  rename(variable = `Number of Workers in Household 6`, value = Households) %>%
  select(RESIDENCE, variable, value) %>%
  mutate(
    variable = case_when(
      variable == "Total, number of workers in household" ~ "hh_tot",
      variable == "0 workers" ~ "wrk0",
      variable == "1 worker" ~ "wrk1",
      variable == "2 workers" ~ "wrk2",
      variable == "3 workers" ~ "wrk3", 
      variable == "4-or-more workers" ~ "wrk4"
    )
  ) %>%
  filter(!is.na(variable)) %>%
  spread(key = variable, value = value) %>%
  filter(hh_tot > 0)
```

## Household Size

The base year zonal SE data contains a range of zonal average household sizes,
as shown by the blue histogram bars below. The Census block group histogram,
shown in orange, has a similar range of household sizes which makes it a good 
candidate for model estimation. Although the differing level of aggregation 
between block groups and zones results in the distribution having different 
dispersion or variance, the fact that both distributions are centered on the 
regional average of 2.5 persons per household implies their consistency. 

```{r size range, warning=FALSE}
se_tbl <- read_csv(
  "data/output/se_data/se_2016.csv",
  col_types = cols(
    .default = col_double(),
    Type = col_character()
  )
) %>%
  filter(Type == "Internal")

# se data
se_tbl <- se_tbl %>%
  mutate(pph = HH_POP / HH)

# census
size <- dec_bg %>%
  as.data.frame() %>%
  filter(hh_tot > 0) %>%
  select(GEOID, hh_tot, hh_pop, siz1:siz7) %>%
  mutate(
    avg_size = hh_pop / hh_tot,
    siz4 = siz4 + siz5 + siz6 + siz7
  ) %>%
  select(-c(siz5, siz6, siz7)) %>%
  gather(key = size, value = n, siz1:siz4) %>%
  mutate(share = n / hh_tot)

plot_ly() %>%
  add_trace(
    data = se_tbl, x = ~pph, type = "histogram", name = "Model",
    alpha = .6, bingroup = 1, nbinsx = 50
  ) %>%
  add_trace(
    data = size, x = ~avg_size, type = "histogram", name = "Census",
    alpha = .6, bingroup = 1
  ) %>%
  layout(
    title = "Average Household Size",
    xaxis = list(
      title = "Persons per Household"
    ),
    yaxis = list(
      title = "Count"
    ),
    barmode = "overlay"
  )
```

```{r mean_size}
# calculate
mean_size <- calc_mean_share(size, "avg_size", "size", bin = 0.1) %>%
  spread(group, share) %>%
  rename(avg_size = bin) %>%
  ungroup() %>%
  mutate(avg_size = round(avg_size, 1))

# Manual adjustments
adjustment_table <- tribble(
  ~avg_size, ~siz1, ~siz2, ~siz3, ~siz4,
  1,         1,     0,     0,     0
)
mean_size <- bind_rows(mean_size, adjustment_table) %>%
  arrange(avg_size)

mean_size <- mean_size %>% gather(size, share, -avg_size)

# smooth and predict
size_min <- 1
size_max <- 4
size_functions <- fit_models(
  mean_size, "avg_size", "size", 
  x = seq(size_min, size_max, 0.01),  degree = 3
) %>%
  rename(avg_size = avg, size = group)

# Check that the shares of each bin add to 1, which they will not after 
# rounding. Adjust the category with the largest share to correct.
size_functions <- size_functions %>%
  group_by(avg_size) %>%
  mutate(
    max = ifelse(share == max(share), 1, 0),
    diff = 1 - sum(share),
    share = round(share + diff * max, 4)
  ) %>%
  select(-c(max, diff)) %>%
  ungroup()

spread_size <- size_functions %>%
  pivot_wider(names_from = size, values_from = share)

# vars for bullet list below
siz1 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz1") %>% .$share, 2)
siz2 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz2") %>% .$share, 2)
siz3 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz3") %>% .$share, 2)
siz4 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz4") %>% .$share, 2)
```

<p>
In the graph below, each green dot is the share of 1-person households in a
block group based on the block group's average household size. (Click on the 
siz2, siz3, and siz4 entries in the legend to the right of the chart to turn 
them off and focus on the green, 1-person households.) Multiple block groups 
that have the same average household size will usually have slight differences 
in their shares of 1-person households. For example, block groups with an 
average household size of 2.0 generally have 37-47% 1-person households; 
whereas, block groups with close to 3.5 persons per household on average 
typically have only 5-15% 1-person households. The same is true of the dots 
of different colors representing 2-, 3-, and 4+ households. A polynomial 
equation is fit to each set of colored dots. For any average household size, 
these polynomials can be evaluated to determine the percent of households in
each size category.

For example, for a zone with an average household size of 2.3, the percent of
households by size would be:

- 1-person: `r siz1` (green curve)
- 2-person: `r siz2` (orange curve)
- 3-person: `r siz3` (purple curve)
- 4-person: `r siz4` (pink curve)

```{r fig_size, echo=FALSE, warning=FALSE}
p <- ggplot(data = NULL, aes(x = avg_size, y = share, color = size)) +
  geom_point(data = size, alpha = 0.5) +
  geom_line(data = size_functions, size = 2) +
  xlab("Average Household Size") +
  scale_color_brewer("Size", type = "qual", palette = "Dark2") +
  scale_x_continuous(lim = c(1, 3.5)) +
  theme_bw()

ggplotly(p) %>%
  layout(
    title = "Persons by Average Size",
    margin = list(t = 50)
  )
```

<p>
At the extremes of average household size, manual edits were required to adjust
curve behavior due to the low number of observations in
these ranges. This same treatment was applied to create all marginal tables.

The model implements the curves above using a look-up table. The table below
shows a segment of rows from the look-up table the model uses to dis-aggregate
zonal data into households by size.

```{r show_size_lookup, results = "asis", achor = "table"}
a <- size_functions %>%
  mutate(
    size = gsub("siz", "", size),
    size = paste(size, "-person", sep = "")
  ) %>%
  rename(`Average Household Size` = avg_size) %>%
  spread(size, share)

a %>%
  filter(`Average Household Size` %in% seq(2.00, 2.06, .01)) %>%
  kable(caption = "Household Size Lookup Table, Sample Rows") %>%
  kable_styling()
```

## Household Workers

The chart below shows the model and Census distributions of workers per
household. The Census Transportation Planning Program (CTPP) data was used at
the TAZ level, which contains more than enough observations to estimate a robust
curve across the entire range of zonal values. The distribution of workers per
household in the zonal data (developed from ACS) has a slightly different
distribution from the older CTPP data set. However, the difference is small
enough (1.2 vs 1.3 workers per household) that the CTPP data is deemed suitable
for use.

```{r worker range, warning=FALSE}
# se data distribution
se_tbl <- se_tbl %>%
  mutate(
    Workers = Pct_Worker / 100 * HH_POP,
    wph = Workers / HH
  )

# census distribution
workers <- ctpp_tbl %>%
  mutate(
    avg_workers = (wrk0 * 0 + wrk1 * 1 + wrk2 * 2 + wrk3 * 3 + wrk4 * 4) / hh_tot,
    wrk3 = wrk3 + wrk4
  ) %>%
  select(-wrk4) %>%
  filter(hh_tot > 0) %>%
  select(RESIDENCE, avg_workers, hh_tot, wrk0:wrk3) %>%
  group_by(RESIDENCE) %>%
  gather(key = workers, n, wrk0:wrk3) %>%
  mutate(share = n / hh_tot)

plot_ly() %>%
  add_trace(
    data = se_tbl, x = ~wph, type = "histogram", alpha = .6,
    name = "Model", bingroup = 1, nbinsx = 50
  ) %>%
  add_trace(
    data = workers, x = ~avg_workers, type = "histogram", alpha = .6,
    name = "Census", bingroup = 1
  ) %>%
  layout(
    title = "Average Workers per Household",
    xaxis = list(
      title = "Workers per Household"
    ),
    yaxis = list(
      title = "Count"
    ),
    barmode = "overlay"
  )
```

```{r mean_workers}
# calculate
mean_workers <- calc_mean_share(
  workers, "avg_workers", "workers", bin_width = 0.1
) %>%
  spread(group, share) %>%
  rename(avg_workers = bin)

# manual adjustments
adjustment_table <- tribble(
  ~avg_workers, ~wrk0, ~wrk1, ~wrk2, ~wrk3,
  0,            1,     0,     0,     0
)
mean_workers <- bind_rows(mean_workers, adjustment_table) %>%
  arrange(avg_workers)

mean_workers <- mean_workers %>% gather(workers, share, -avg_workers)

# smooth and predict
min = 0
max = 2
workers_functions <- fit_models(mean_workers, "avg_workers", "workers", 
                             x = seq(min, max, 0.01),  degree = 3) %>%
  rename(avg_workers = avg, workers = group)

# Check that the shares of each bin add to 1, which they will not after 
# rounding. Adjust the category with the largest share to correct.
workers_functions <- workers_functions %>%
  group_by(avg_workers) %>%
  mutate(
    max = ifelse(share == max(share), 1, 0),
    diff = 1 - sum(share),
    share = round(share + diff * max, 4)
  ) %>%
  select(-c(max, diff)) %>%
  ungroup()

spread_workers <- workers_functions %>%
  pivot_wider(names_from = workers, values_from = share)
```

<p>
Similar to the household size curve, Census data tables were
used to calculate the share of households by number of workers at different
levels of zonal average workers per household. The chart below shows the raw data from CTPP TAZ as well as the fitted curves.

```{r fig_worker, warning=FALSE}
p <- ggplot(data = NULL, aes(x = avg_workers, y = share, color = workers)) +
  geom_point(data = workers, alpha = 0.5) +
  geom_line(data = workers_functions, size = 2) +
  xlab("Average Household workers") +
  scale_color_brewer("Workers", type = "qual", palette = "Dark2") +
  scale_x_continuous(lim = c(0, 2)) +
  theme_bw()

ggplotly(p) %>%
  layout(
    title = "Workers by Average Workers",
    margin = list(t = 50)
  )
```

## Household Income

Before developing curves for median income, Caliper had to determine appropriate income groups. ACS data is already grouped to some extent,
which limits the possible breakpoints in the final grouping. The histogram
below shows the final income grouping and count of households in each group.

```{r, fig.height=4}
inc_histo <- acs_bg %>%
  summarize(across(starts_with("inc"), sum)) %>%
  st_drop_geometry() %>%
  select(-inc_med) %>%
  pivot_longer(cols = everything(), names_to = "inc", values_to = "count") %>%
  mutate(
    inc = gsub("inc", "", inc),
    inc = gsub("p", "", inc),
    inc = as.numeric(inc),
    inc = case_when(
      inc <= 35 ~ "0-35",
      inc <= 75 ~ "35-75",
      inc <= 150 ~ "75-150",
      TRUE ~ "150+",
    ),
    inc = factor(
      inc,
      levels = c("0-35", "35-75", "75-150", "150+"),
      ordered = TRUE
    )
  ) %>%
  group_by(inc) %>%
  summarize(count = sum(count))
  

plot_ly() %>%
  add_trace(
    data = inc_histo, x = ~inc, y = ~count, type = "bar", name = "Model",
    alpha = .6
  ) %>%
  layout(
    xaxis = list(title = "Income Range"),
    yaxis = list(title = "Households")
  )
  
```

```{r}
# regional median income
# source: https://data.census.gov/cedsci/table?q=median%20income&g=0500000US37063,37135,37183&tid=ACSST1Y2019.S1901&hidePreview=true
regional_median <- 65317

se_tbl <- se_tbl %>%
  mutate(inc_ratio = Median_Inc / regional_median)

# census distribution
income <- acs_bg %>%
  as.data.frame() %>%
  filter(hh_tot > 0, !is.na(inc_med)) %>%
  mutate(
    inc_ratio = inc_med / regional_median,
    incL = inc10 + inc15 + inc20 + inc25 + inc30 + inc35,
    incML = inc40 + inc45 + inc50 + inc60 + inc75,
    incMH = inc100 + inc125 + inc150,
    incH =  inc200 + inc200p
  ) %>%
  select(GEOID, hh_tot, inc_ratio, incL:incH) %>%
  group_by(GEOID) %>%
  gather(key = income, value = n, incL:incH) %>%
  mutate(share = n / hh_tot)
```

The prediction metric used for income is the median income of the zone divided
by the regional median (`r paste0("$", format(regional_median, big.mark = ","))`). This provides an estimation range on a similar scale as
the other variables for convenience ( e.g. 0.2 - 3.0 instead of \$0 - \$250,000).

The chart below shows the distribution of model and Census data. The model has zones without households (and thus zero median income), but otherwise the
distributions are similar, particularly allowing for the slightly different levels of aggregation.

```{r}
plot_ly() %>%
  add_trace(
    data = se_tbl, x = ~inc_ratio, type = "histogram", name = "Model",
    alpha = .6, bingroup = 1, nbinsx = 50
  ) %>%
  add_trace(
    data = income, x = ~inc_ratio, type = "histogram", name = "Census",
    alpha = .6, bingroup = 1
  ) %>%
  layout(
    title = "Model TAZ Income Ratio",
    xaxis = list(
      title = "Zonal Median Income / MSA Median Income"
    ),
    yaxis = list(
      title = "Count"
    ),
    barmode = "overlay"
  )
```


```{r}
# calculate
mean_income <- calc_mean_share(income, "inc_ratio", "income", bin_width = 0.1) %>%
  spread(group, share) %>%
  rename(inc_ratio = bin) %>%
  filter(!is.na(inc_ratio)) %>%
  ungroup() %>%
  mutate(inc_ratio = round(inc_ratio, 1))

# manual adjustments
# adjustment_table <- tribble(
#   ~inc_ratio, ~incH, ~incL, ~incMH, ~incML,
#   0,          1,     0,     0,      0
# )
# mean_income <- bind_rows(mean_income, adjustment_table) %>%
#   arrange(avg_vehicles)

mean_income <- mean_income %>% gather(income, share, -inc_ratio)

# smooth and predict
inc_min <- .22
inc_max <- 2.5
income_functions <- fit_models(mean_income, "inc_ratio", "income", 
                             x = seq(inc_min, inc_max, 0.01),  degree = 4) %>%
  rename(inc_ratio = avg, income = group)

# Check that the shares of each bin add to 1, which they will not after 
# rounding. Adjust the category with the largest share to correct.
income_functions <- income_functions %>%
  group_by(inc_ratio) %>%
  mutate(
    share = round(share, 4),
    max = ifelse(share == max(share), 1, 0),
    diff = 1 - sum(share),
    share = round(share + diff * max, 4)
  ) %>%
  select(-c(max, diff)) %>%
  ungroup()

spread_income <- income_functions %>%
  pivot_wider(names_from = income, values_from = share) %>%
  relocate(incL, .after = inc_ratio) %>%
  relocate(incML, .after = incL) %>%
  relocate(incMH, .after = incML)
```
 
<p>
The chart below shows the raw observations and fitted curves.

```{r}
p <- ggplot(data = NULL, aes(x = inc_ratio, y = share, color = income)) +
  geom_point(data = income, alpha = 0.5) +
  geom_line(data = income_functions, size = 2) +
  xlab("Ratio of Median Income to Regional Median Income") +
  scale_color_brewer("Income", type = "qual", palette = "Dark2") +
  scale_x_continuous(lim = c(inc_min, inc_max)) +
  theme_bw()

ggplotly(p) %>%
  layout(title = "Income by Proportion of Regional Income") %>%
  layout(margin = list(t = 30))
```

## Household Vehicles

The TRMG2 model utilizes an auto-ownership model, and as a result does
not require disaggregation by household vehicles.

```{r write_output, eval=FALSE}
write_csv(spread_size, "data/output/disagg_model/size_curves.csv")
write_csv(spread_workers, "data/output/disagg_model/worker_curves.csv")
write_csv(spread_income, "data/output/disagg_model/income_curves.csv")
```

