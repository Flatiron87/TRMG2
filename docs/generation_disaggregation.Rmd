---
title: "Disaggregate Curves"
author: "Caliper Corporation"
date: "12/11/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(dplyr.summarise.inform = FALSE)
options(scipen = 999)

library(tidyverse)
library(plotly)
library(knitr)
library(kableExtra)
source("R/load_census_data.R")
source("R/calc_shares.R")
```

```{r load census data}
shapes <- load_census_data()

acs_bg <- shapes$acs_bg
acs_tract <- shapes$acs_tract
dec_bg <- shapes$dec_bg

taz <- sf::read_sf("data/input/tazs/tazs 2020-12-08.shp") %>%
  st_transform(crs = st_crs('+proj=longlat +datum=WGS84'))
taz <- st_transform(taz, st_crs(acs_bg)) %>% st_make_valid()
```

# Marginal distribution

A marginal distribution curve relates an aggregate, zonal attribute to
the shape of a one-dimensional distribution. For example, a zone
with 3.5 persons-per-household on average will have a high percentage of 3- and
4-person households. A zone with an average of 1.5 persons-per-household will
have more 1- and 2-person households.

In the Triangle, the marginal distribution curves estimated are:

  * Size (1-4+)
  * Income
    * Low: $0 - $24,999
    * Medium-Low: $25,000 - $49,999
    * Medium-High: $50,000 - $99,999
    * High: $100,000 and above
  * Workers (0-3+)
  * Vehicles (0-3+)
  
These curves are estimated from Census data, and the data is taken from
different data products and geographies depending on availability. For example,
the data needed to estimate the worker curve is only available from the American
Community Survey (ACS) product known as the Census Transportation Planning
Package (CTPP). Vehicle and income information is available from the ACS 5-year
file directly, and size information is available from multiple products.

```{r, warning=FALSE}
# Read in worker data from CTPP table A112109 at the TAZ level.
# It isn't available from the ACS at anything below tract, which is too coarse.
ctpp_tbl <- read_csv(
  "data/input/census_data/2012_2016_ctpp_workers.csv", skip = 2
) %>%
  rename(variable = `Number of Workers in Household 6`, value = Households) %>%
  select(RESIDENCE, variable, value) %>%
  mutate(
    variable = case_when(
      variable == "Total, number of workers in household" ~ "hh_tot",
      variable == "0 workers" ~ "wrk0",
      variable == "1 worker" ~ "wrk1",
      variable == "2 workers" ~ "wrk2",
      variable == "3 workers" ~ "wrk3", 
      variable == "4-or-more workers" ~ "wrk4"
    )
  ) %>%
  filter(!is.na(variable)) %>%
  spread(key = variable, value = value) %>%
  filter(hh_tot > 0)
```

## Household Size

The base year zonal SE data contains a range of zonal average household sizes,
as shown by the blue histogram bars below. The Census blockgroup histogram,
shown in orange, has a similar range of household sizes, which makes it a good
candidate for model estimation.

```{r size range}
input_se <- read_csv("data/output/se_data/se_2016.csv")

# se data
input_se <- input_se %>%
  mutate(pph = HH_POP / HH)

# census
size <- dec_bg %>%
  as.data.frame() %>%
  filter(hh_tot > 0) %>%
  select(GEOID, hh_tot, hh_pop, siz1:siz7) %>%
  mutate(
    avg_size = hh_pop / hh_tot,
    siz4 = siz4 + siz5 + siz6 + siz7
  ) %>%
  select(-c(siz5, siz6, siz7)) %>%
  gather(key = size, value = n, siz1:siz4) %>%
  mutate(share = n / hh_tot)

plot_ly() %>%
  add_trace(
    data = input_se, x = ~pph, type = "histogram", name = "Model",
    alpha = .6
  ) %>%
  add_trace(
    data = size, x = ~avg_size, type = "histogram", name = "Census",
    alpha = .6
  ) %>%
  layout(
    title = "Average Household Size",
    xaxis = list(
      title = "Persons per Household"
    ),
    yaxis = list(
      title = "Count"
    ),
    barmode = "overlay"
  )
```

```{r mean_size}
# calculate
mean_size <- calc_mean_share(size, "avg_size", "size", bin = 0.1) %>%
  spread(group, share) %>%
  rename(avg_size = bin) %>%
  ungroup() %>%
  mutate(avg_size = round(avg_size, 1))

# Manual adjustments
adjustment_table <- tribble(
  ~avg_size, ~siz1, ~siz2, ~siz3, ~siz4,
  1,         1,     0,     0,     0
)
mean_size <- bind_rows(mean_size, adjustment_table) %>%
  arrange(avg_size)

mean_size <- mean_size %>% gather(size, share, -avg_size)

# smooth and predict
size_min <- 1
size_max <- 4
size_functions <- fit_models(
  mean_size, "avg_size", "size", 
  x = seq(size_min, size_max, 0.01),  degree = 3
) %>%
  rename(avg_size = avg, size = group)

# Check that the shares of each bin add to 1, which they will not after 
# rounding.  Adjust the category with the largest share to correct.
size_functions <- size_functions %>%
  group_by(avg_size) %>%
  mutate(
    max = ifelse(share == max(share), 1, 0),
    diff = 1 - sum(share),
    share = round(share + diff * max, 4)
  ) %>%
  select(-c(max, diff)) %>%
  ungroup()

spread_size <- size_functions %>%
  pivot_wider(names_from = size, values_from = share)

# vars for bullet list below
siz1 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz1") %>% .$share, 2)
siz2 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz2") %>% .$share, 2)
siz3 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz3") %>% .$share, 2)
siz4 <- round(
  mean_size %>% filter(avg_size == 2.3, size == "siz4") %>% .$share, 2)
```

<p>
In the graph below, each green dot is the share of 1-person households in a
blockgroup. Multiple blockgroups may have the same average household size, but
they will usually have slight differences in the share of 1-person households.
The same is true of the dots for different colors representing 2-, 3-, and 4+
households. A polynomial equation is fit to each set of colored dots. For any
average household size, these polynomials can be evaluated to determine the
percent of households in each size category.

For example, for a zone with an average household size of 2.3, the percent of
households by size would be:

- 1-person: `r siz1` (green curve)
- 2-person: `r siz2` (orange curve)
- 3-person: `r siz3` (purple curve)
- 4-person: `r siz4` (pink curve)

```{r fig_size, echo=FALSE, warning=FALSE}
p <- ggplot(data = NULL, aes(x = avg_size, y = share, color = size)) +
  geom_point(data = size, alpha = 0.5) +
  geom_line(data = size_functions, size = 2) +
  xlab("Average Household Size") +
  scale_color_brewer("Size", type = "qual", palette = "Dark2") +
  scale_x_continuous(lim = c(1, 3.5)) +
  theme_bw()

ggplotly(p) %>%
  layout(
    title = "Persons by Average Size",
    margin = list(t = 50)
  )
```

<p>
At the extremes of average household size, manual edits were required to adjust
curve behavior due to the low number of observations in
these ranges.  This same treatment was applied to create all marginal tables.

The model implements the curves above using a lookup table. The table below
shows a segment of rows from the look-up table the model uses to dis-aggregate
zonal data into households by size.

```{r show_size_lookup, results = "asis", achor = "table"}
a <- size_functions %>%
  mutate(
    size = gsub("siz", "", size),
    size = paste(size, "-person", sep = "")
  ) %>%
  rename(`Average Household Size` = avg_size) %>%
  spread(size, share)

a %>%
  filter(`Average Household Size` %in% seq(2.00, 2.06, .01)) %>%
  kable(caption = "Household Size Lookup Table, Sample Rows") %>%
  kable_styling()
```

## Household Workers

The chart below shows the model and Census distributions of workers per
household. The Census Transportation Planning Program (CTPP) data was used at
the TAZ level, which contains more than enough observations to estimate a robust
curve across the entire range of zonal values.

```{r worker range}
# se data distribution
input_se <- input_se %>%
  mutate(wph = Workers / HH)

# census distribution
workers <- ctpp_tbl %>%
  mutate(
    avg_workers = (wrk0 * 0 + wrk1 * 1 + wrk2 * 2 + wrk3 * 3 + wrk4 * 4) / hh_tot,
    wrk3 = wrk3 + wrk4
  ) %>%
  select(-wrk4) %>%
  filter(hh_tot > 0) %>%
  select(RESIDENCE, avg_workers, hh_tot, wrk0:wrk3) %>%
  group_by(RESIDENCE) %>%
  gather(key = workers, n, wrk0:wrk3) %>%
  mutate(share = n / hh_tot)

plot_ly() %>%
  add_trace(
    data = input_se, x = ~wph, type = "histogram", alpha = .6,
    name = "Model"
  ) %>%
  add_trace(
    data = workers, x = ~avg_workers, type = "histogram", alpha = .6,
    name = "Census"
  ) %>%
  layout(
    title = "Average Workers per Household",
    xaxis = list(
      title = "Workers per Household"
    ),
    yaxis = list(
      title = "Count"
    ),
    barmode = "overlay"
  )
```

```{r mean_workers}
# calculate
mean_workers <- calc_mean_share(
  workers, "avg_workers", "workers", bin_width = 0.1
) %>%
  spread(group, share) %>%
  rename(avg_workers = bin)

# manual adjustments
adjustment_table <- tribble(
  ~avg_workers, ~wrk0, ~wrk1, ~wrk2, ~wrk3,
  0,            1,     0,     0,     0
)
mean_workers <- bind_rows(mean_workers, adjustment_table) %>%
  arrange(avg_workers)

mean_workers <- mean_workers %>% gather(workers, share, -avg_workers)

# smooth and predict
min = 0
max = 2
workers_functions <- fit_models(mean_workers, "avg_workers", "workers", 
                             x = seq(min, max, 0.01),  degree = 3) %>%
  rename(avg_workers = avg, workers = group)

# Check that the shares of each bin add to 1, which they will not after 
# rounding.  Adjust the category with the largest share to correct.
workers_functions <- workers_functions %>%
  group_by(avg_workers) %>%
  mutate(
    max = ifelse(share == max(share), 1, 0),
    diff = 1 - sum(share),
    share = round(share + diff * max, 4)
  ) %>%
  select(-c(max, diff)) %>%
  ungroup()

spread_workers <- workers_functions %>%
  pivot_wider(names_from = workers, values_from = share)
```

<p>
Similar to the household size curve, census data tables were
used to calculate the share of households by number of workers at different
levels of zonal average workers per household. The chart below shows the raw data from CTPP TAZ as well as the fitted curves.

```{r fig_worker, warning=FALSE}
p <- ggplot(data = NULL, aes(x = avg_workers, y = share, color = workers)) +
  geom_point(data = workers, alpha = 0.5) +
  geom_line(data = workers_functions, size = 2) +
  xlab("Average Household workers") +
  scale_color_brewer("Workers", type = "qual", palette = "Dark2") +
  scale_x_continuous(lim = c(0, 2)) +
  theme_bw()

ggplotly(p) %>%
  layout(
    title = "Workers by Average Workers",
    margin = list(t = 50)
  )
```

## Household Vehicles

The chart below confirms that Census blockgroups show the same range of vehicles
per household as the model TAZ data, which gives confidence in it's ability to
predict the relationship across the entire spectrum.

```{r vehicle range}
# model data
input_se <- input_se %>%
  mutate(vph = Vehicles / HH)

# census data
vehicles <- acs_bg %>%
  as.data.frame() %>%
  filter(hh_tot > 0) %>%
  select(GEOID, hh_tot, veh_tot:veh5) %>%
  mutate(
    veh_tot = case_when(
      !is.na(veh_tot) ~ veh_tot,
      is.na(veh_tot) ~ veh1 + veh2 * 2 + veh3 * 3 + veh4 * 4 + veh5 * 5.1
    ),
    avg_vehicles = veh_tot / hh_tot,
    veh3 = veh3 + veh4 + veh5
  ) %>%
  select(-veh4, -veh5) %>%
  group_by(GEOID) %>%
  gather(key = vehicles, value = n, veh0:veh3) %>%
  mutate(share = n / hh_tot)

plot_ly() %>%
  add_trace(
    data = input_se, x = ~vph, type = "histogram", name = "Model",
    alpha = .6, nbinsx = 15
  ) %>%
  add_trace(
    data = vehicles, x = ~avg_vehicles, type = "histogram", name = "Census",
    alpha = .6, nbinsx = 15
  ) %>%
  layout(
    title = "Average Vehicles per Household",
    xaxis = list(
      title = "Vehicles per Household"
    ),
    yaxis = list(
      title = "Count"
    ),
    barmode = "overlay"
  )
```

```{r mean_vehicles}
# calculate
mean_vehicles <- calc_mean_share(vehicles, "avg_vehicles", "vehicles", bin_width = 0.1) %>%
  spread(group, share) %>%
  rename(avg_vehicles = bin) %>%
  filter(!is.na(avg_vehicles)) %>%
  ungroup() %>%
  mutate(avg_vehicles = round(avg_vehicles, 1))

# manual adjustments
adjustment_table <- tribble(
  ~avg_vehicles, ~veh0, ~veh1, ~veh2, ~veh3,
  0,             1,     0,     0,     0
)
mean_vehicles <- bind_rows(mean_vehicles, adjustment_table) %>%
  arrange(avg_vehicles)

mean_vehicles <- mean_vehicles %>% gather(vehicles, share, -avg_vehicles)

# smooth and predict
veh_min <- 0
veh_max <- 3
vehicles_functions <- fit_models(mean_vehicles, "avg_vehicles", "vehicles", 
                             x = seq(veh_min, veh_max, 0.01),  degree = 4) %>%
  rename(avg_vehicles = avg, vehicles = group)

# Check that the shares of each bin add to 1, which they will not after 
# rounding.  Adjust the category with the largest share to correct.
vehicles_functions <- vehicles_functions %>%
  group_by(avg_vehicles) %>%
  mutate(
    share = round(share, 4),
    max = ifelse(share == max(share), 1, 0),
    # At avg_veh of .58 and .59, the veh0 and veh1 curves switch places as the
    # largest share. Using the max above creates an odd looking jagged cross as
    # a result. This case_when() call corrects that by adjusting the veh0 curve
    # for both .58 and .59. This has no meaningful impact on the model, but
    # makes the curves look a little nicer while ensuring all ratios add
    # to 1.
    max = case_when(
      avg_vehicles != .59 ~ max,
      vehicles == "veh0" ~ 1,
      TRUE ~ 0
    ),
    diff = 1 - sum(share),
    share = round(share + diff * max, 4)
  ) %>%
  select(-c(max, diff)) %>%
  ungroup()

spread_vehicles <- vehicles_functions %>%
  pivot_wider(names_from = vehicles, values_from = share)
```

<p>
The chart below shows the raw data from ACS blockgroups as well as the fitted
curves.

```{r}
p <- ggplot(data = NULL, aes(x = avg_vehicles, y = share, color = vehicles)) +
  geom_point(data = vehicles, alpha = 0.5) +
  geom_line(data = vehicles_functions, size = 2) +
  xlab("Average Vehicles per Household") +
  scale_color_brewer("Vehicles", type = "qual", palette = "Dark2") +
  scale_x_continuous(lim = c(veh_min, veh_max)) +
  theme_bw()

ggplotly(p) %>%
  layout(
    title = "Vehicles by Average Vehicles",
    margin = list(t = 50)
  )
```

## Household Income

Finally, the same treatment was applied for median income. The prediction metric
used for income is the median income of the zone divided by the regional median.
This provides an estimation range on a similar scale as the other variables (
e.g. 0.2 - 3.0 instead of $0 - 250,000). 

The chart below shows the distribution of model and Census data. The distributions are similar, with the exception being that the model has zones
without households (and thus zero median income).

```{r}
# regional median income
# source: https://data.census.gov/cedsci/table?q=median%20income&g=0500000US37063,37135,37183&tid=ACSST1Y2019.S1901&hidePreview=true
regional_median <- 65317

input_se <- input_se %>%
  mutate(inc_ratio = MEDIANINC / regional_median)

# census distribution
income <- acs_bg %>%
  as.data.frame() %>%
  filter(hh_tot > 0, !is.na(inc_med)) %>%
  mutate(
    inc_ratio = inc_med / regional_median,
    incL = inc10 + inc15 + inc20 + inc25,
    incML = inc30 + inc35 + inc40 + inc45 + inc50,
    incMH = inc60 + inc75 + inc100,
    incH = inc125 + inc150 + inc200 + inc200p
  ) %>%
  select(GEOID, hh_tot, inc_ratio, incL:incH) %>%
  group_by(GEOID) %>%
  gather(key = income, value = n, incL:incH) %>%
  mutate(share = n / hh_tot)

plot_ly() %>%
  add_trace(
    data = input_se, x = ~inc_ratio, type = "histogram", name = "Model",
    alpha = .6
  ) %>%
  add_trace(
    data = income, x = ~inc_ratio, type = "histogram", name = "Census",
    alpha = .6
  ) %>%
  layout(
    title = "Model TAZ Income Ratio",
    xaxis = list(
      title = "Zonal Median Income / MSA Median Income"
    ),
    yaxis = list(
      title = "Count"
    ),
    barmode = "overlay"
  )
```

```{r}
# calculate
mean_income <- calc_mean_share(income, "inc_ratio", "income", bin_width = 0.1) %>%
  spread(group, share) %>%
  rename(inc_ratio = bin) %>%
  filter(!is.na(inc_ratio)) %>%
  ungroup() %>%
  mutate(inc_ratio = round(inc_ratio, 1))

# manual adjustments
# adjustment_table <- tribble(
#   ~inc_ratio, ~incH, ~incL, ~incMH, ~incML,
#   0,          1,     0,     0,      0
# )
# mean_income <- bind_rows(mean_income, adjustment_table) %>%
#   arrange(avg_vehicles)

mean_income <- mean_income %>% gather(income, share, -inc_ratio)

# smooth and predict
inc_min <- .22
inc_max <- 2.5
income_functions <- fit_models(mean_income, "inc_ratio", "income", 
                             x = seq(inc_min, inc_max, 0.01),  degree = 4) %>%
  rename(inc_ratio = avg, income = group)

# Check that the shares of each bin add to 1, which they will not after 
# rounding.  Adjust the category with the largest share to correct.
income_functions <- income_functions %>%
  group_by(inc_ratio) %>%
  mutate(
    share = round(share, 4),
    max = ifelse(share == max(share), 1, 0),
    diff = 1 - sum(share),
    share = round(share + diff * max, 4)
  ) %>%
  select(-c(max, diff)) %>%
  ungroup()

spread_income <- income_functions %>%
  pivot_wider(names_from = income, values_from = share) %>%
  relocate(incL, .after = inc_ratio) %>%
  relocate(incML, .after = incL) %>%
  relocate(incMH, .after = incML)
```
 
<p>
The chart below shows the raw observations and fitted curves.
 
```{r}
p <- ggplot(data = NULL, aes(x = inc_ratio, y = share, color = income)) +
  geom_point(data = income, alpha = 0.5) +
  geom_line(data = income_functions, size = 2) +
  xlab("Ratio of Median Income to Regional Median Income") +
  scale_color_brewer("Income", type = "qual", palette = "Dark2") +
  scale_x_continuous(lim = c(inc_min, inc_max)) +
  theme_bw()

ggplotly(p) %>%
  layout(title = "Income by Proportion of Regional Income")
```

```{r write_output}
# The if statement makes sure that this code block is only ever executed
# manually.
if (1 == 0) {
  write_csv(spread_size, "data/output/disagg_model/size_curves.csv")
  write_csv(spread_workers, "data/output/disagg_model/worker_curves.csv")
  write_csv(spread_vehicles, "data/output/disagg_model/vehicle_curves.csv")
  write_csv(spread_income, "data/output/disagg_model/income_curves.csv")
}
```

